Require Import interfaces.notation rewrite.proper prop_eq sprop tactics.misc.

(** Tagging via rewriting a tag equation *)

Create HintDb rewrite_swap_tag discriminated.
Inductive RewriteSwapTag {A} (term : A) := DeclareRewriteSwapTag : A → RewriteSwapTag term.
Arguments DeclareRewriteSwapTag {_ _} _.

Ltac swap_rewrite_tag t :=
  let s := constr:( ltac:(
      solve [ typeclasses eauto with rewrite_swap_tag nocore
            | idtac "No instance to swap tag of" t;
              fail 1 "No instance to swap tag of" t ]
    ) : RewriteSwapTag t ) in
  lazymatch s with DeclareRewriteSwapTag ?t' => constr:(t') end.


(** Assumes the goal is [ |- False → G ].
   Runs the given [ tactic_to_run_on_goal ] when the goal is [ G ]
   (after an intro). Captures the new goal [ ?H ], by finishing
   the proof (via an exfalso) as a term [let _ := ?H in _ ].
*)
Ltac run_tactic_on_term_inner tactic_to_run_on_goal :=
  let altered_goal_term := fresh "altered_goal_term" in notypeclasses refine (let altered_goal_term := _ in _);
  let altered_goal_term_evar := eval red in altered_goal_term in clear altered_goal_term;
  let false_dummy_var := fresh "false_dummy_var" in intro false_dummy_var;
  tactic_to_run_on_goal;
  let g := get_goal in unify g altered_goal_term_evar;
  destruct false_dummy_var.

(** Runs [ tactic_to_run_on_term ] in a context where the goal is
   [ term_to_run_tactic_on ] (which must be a type). Returns a term
   [ let _ := H in λ f:False, t ] where [ H ] is the new goal after the tactic
   is run, and [ t ] is the proof term generated by the tactic,
   with the final hole of type [ H ] filled in by destructing [ f ]. *)
Ltac run_tactic_on_term_full term_to_run_tactic_on tactic_to_run_on_term :=
  constr_from_tac uconstr:(forall _ : False, term_to_run_tactic_on)
                  ltac:(run_tactic_on_term_inner tactic_to_run_on_term).

(** As above, but just returns the new goal, without the proof term. *)
Ltac run_tactic_on_term term_to_run_tactic_on tactic_to_run_on_term :=
  let t := run_tactic_on_term_full term_to_run_tactic_on tactic_to_run_on_term in
  lazymatch t with let _ := ?G in _ => constr:(G) end.

(** Rewrites an [ equation_to_rewrite ] [ E : ?x ≡ _ ] in [ term_to_rewrite_in ],
   which must be a type, and calls [ continuation_tac ], passing the
   resolved [ x ] and rewritten term. *)
Ltac rewrite_in_term_gen equation_to_rewrite continuation_tactic term_to_rewrite_in :=
  let t := run_tactic_on_term_full term_to_rewrite_in ltac:(case equation_to_rewrite) in
  lazymatch t with let _ := ?G in (λ f, match ?pf with eq_refl => _ end) =>
    lazymatch type of pf with ?x ≡ _ =>
      continuation_tactic x G
    end
  end.

Local Ltac forall_subst P x := lazymatch P with (∀ y, ?Py) => constr:(match x with y => Py end) end.

Ltac chain_rewrite next_rewrite_tac k tag_term rewritten_term :=
  let swapped_tag_term := swap_rewrite_tag tag_term in
  let k' g h := (let g' := forall_subst g tag_term in
                 let h' := forall_subst h swapped_tag_term in
                 k g' h'
  ) in
  lazymatch eval pattern tag_term in rewritten_term with (λ tagged_term_var : ?T, ?F) _ =>
    next_rewrite_tac uconstr:(forall tagged_term_var : T, F) k'
  end.

Ltac rewrite_in_term equation_to_rewrite next_rewrite_tac term_to_rewrite k
  := rewrite_in_term_gen equation_to_rewrite ltac:(chain_rewrite next_rewrite_tac k) term_to_rewrite.

Ltac drop_rewrite_tags change_tac tagged :=
  let x := eval red in tagged in
  let drop := fresh "drop" in set (drop := tagged);
  change_tac drop tagged;
  change drop with x; clear drop.

Ltac rewrite_in_term_at equation_to_rewrite change_tac next_rewrite_tac term_to_rewrite k :=
  let then_drop_terms tagged G := (
    let G' := run_tactic_on_term G ltac:(drop_rewrite_tags change_tac tagged) in
    chain_rewrite next_rewrite_tac k tagged G'
  ) in
  rewrite_in_term_gen equation_to_rewrite then_drop_terms term_to_rewrite.

Ltac tag_rewrite_done t k := let t' := constr:(t) in k t' t'.

Ltac hyp_rewrite_gen clear_tags H P Q :=
  first [
    let pf := proper_solution (impl P Q) in
    let pf' := clear_tags pf in
    let Q' := clear_tags Q in
    let H' := fresh H in pose proof pf' H : Q' as H'; clear H; rename H' into H
  | idtac "Could not solve proper goal.";
    assert (impl P Q) ].

Ltac goal_rewrite_gen clear_tags P Q :=
  first [
    let pf := proper_solution (impl Q P) in
    let pf' := clear_tags pf in
    let Q' := clear_tags Q in
    simple notypeclasses refine (pf' _); change Q'
  | idtac "Could not solve proper goal.";
    assert (impl Q P)
  ].

Ltac goal_debug_rewrite P Q := assert (impl Q P).

